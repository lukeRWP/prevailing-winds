# IMP Application Manifest
# Defines all environments, VM topology, and pipeline behavior
# The orchestrator reads this file to discover and manage environments

name: imp
displayName: "IMP Expansions Management"
repo: "git@github.com:lukeRWP/Expansions-Management.git"
vaultPrefix: "secret/apps/imp"

# Ansible group names — maps VM roles to inventory group names.
# The inventory generator defaults to <app>_<role>s but some roles need overrides.
ansibleGroups:
  client: imp_clients
  server: imp_servers
  database: imp_databases
  storage: imp_storage

# Build configuration — how to build deployment artifacts
build:
  env: { NODE_ENV: development }
  components:
    client:
      dir: client
      install: "npm ci --legacy-peer-deps"
      build: "npm run build"
      tarball:
        name: "client.tar.gz"
        from: "build"
        args: "-C build ."
    server:
      dir: server
      install: "npm ci"
      tarball:
        name: "server.tar.gz"
        includes: [index.js, package.json, package-lock.json, src/, settings/, utils/]

# Database configuration — drives MySQL role and app-server env vars
databases:
  list:
    - IMP_PROJECTS
    - IMP_PROGRAMS
    - IMP_LOCATIONS
    - IMP_USERS
    - IMP_MILESTONES
    - IMP_CAPITAL
    - IMP_ADMIN
    - IMP_REPORTING
    - IMP_ANALYTICS
    - IMP_IMPORTS
    - IMP_EXPORTS
    - IMP_FILES
    - IMP_NOTES
  schemaPrefix: "IMP_"
  adminDb: "IMP_ADMIN"
  envVars:
    MAIN_DATABASE: IMP_PROJECTS
    PROJECT_DB: IMP_PROJECTS
    PROGRAM_DB: IMP_PROGRAMS
    LOCATION_DB: IMP_LOCATIONS
    USER_DB: IMP_USERS
    MILESTONE_DB: IMP_MILESTONES
    CAPITAL_DB: IMP_CAPITAL
    ADMIN_DB: IMP_ADMIN
    REPORTING_DB: IMP_REPORTING
    ANALYTICS_DB: IMP_ANALYTICS
    IMPORT_DB: IMP_IMPORTS
    EXPORT_DB: IMP_EXPORTS
    FILES_DB: IMP_FILES
    NOTES_DB: IMP_NOTES

# VM template — what services each environment gets
vmTemplate:
  roles:
    client:
      - common
      - node-exporter
      - nodejs
      - nginx
      - app-client
    server:
      - common
      - node-exporter
      - nodejs
      - app-server
    database:
      - common
      - node-exporter
      - mysql
    storage:
      - common
      - node-exporter
      - minio
  healthChecks:
    server:
      path: "/health/live"
      port: 2727
    storage:
      path: "/minio/health/live"
      port: 9000
    database:
      type: tcp
      port: 3306
    client:
      path: "/"
      port: 443
      scheme: https

# Environments — dynamically extensible
# Adding a new env: add a block here, then POST /api/_y_/apps/imp/envs
environments:
  dev:
    vlan: 100
    cidr: "10.0.100.0/24"
    gateway: "10.0.100.254"
    terraformWorkspace: "dev"
    hosts:
      client:
        ip: "10.0.100.10"
        externalIp: "10.0.3.10"
        proxmoxNode: "prx002"
      server:
        ip: "10.0.100.11"
        proxmoxNode: "prx002"
      database:
        ip: "10.0.100.12"
        proxmoxNode: "prx002"
      storage:
        ip: "10.0.100.13"
        proxmoxNode: "prx002"
    pipeline:
      autoDeployBranch: "master"
      requiresApproval: false

  qa:
    vlan: 110
    cidr: "10.0.110.0/24"
    gateway: "10.0.110.254"
    terraformWorkspace: "qa"
    hosts:
      client:
        ip: "10.0.110.10"
        externalIp: "10.0.3.20"
        proxmoxNode: "prx002"
      server:
        ip: "10.0.110.11"
        proxmoxNode: "prx002"
      database:
        ip: "10.0.110.12"
        proxmoxNode: "prx002"
      storage:
        ip: "10.0.110.13"
        proxmoxNode: "prx002"
    pipeline:
      deployOnTag: "v*"
      requiresApproval: false

  prod:
    vlan: 120
    cidr: "10.0.120.0/24"
    gateway: "10.0.120.254"
    terraformWorkspace: "prod"
    hosts:
      client:
        ip: "10.0.120.10"
        externalIp: "10.0.3.30"
        proxmoxNode: "prx002"
      server:
        ip: "10.0.120.11"
        proxmoxNode: "prx002"
      database:
        ip: "10.0.120.12"
        proxmoxNode: "prx001"
      storage:
        ip: "10.0.120.13"
        proxmoxNode: "prx002"
    pipeline:
      deployOnTag: "v*"
      requiresApproval: true
