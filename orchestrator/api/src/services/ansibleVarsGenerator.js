const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');
const vault = require('./vault');
const logger = require('../utils/logger');

// Maps Vault secret keys → Ansible vault_* variable names
const VAULT_TO_ANSIBLE = {
  mysql_root_password: 'vault_mysql_root_password',
  mysql_user: 'vault_mysql_user',
  mysql_password: 'vault_mysql_password',
  mysql_ssl_user: 'vault_mysql_ssl_user',
  mysql_ssl_password: 'vault_mysql_ssl_password',
  minio_access_key: 'vault_s3_access_key',
  minio_secret_key: 'vault_s3_secret_key',
  auth_secret_key: 'vault_auth_secret_key',
  cookie_secret: 'vault_cookie_secret',
  file_encryption_key: 'vault_file_encryption_key',
  sync_encryption_key: 'vault_sync_encryption_key',
};

async function generateAnsibleVars(appName, envName) {
  const envSecrets = await vault.readSecret(`secret/data/apps/${appName}/${envName}`);
  if (!envSecrets) {
    throw new Error(`No secrets in Vault for ${appName}/${envName}`);
  }

  const vars = {};
  for (const [vaultKey, ansibleKey] of Object.entries(VAULT_TO_ANSIBLE)) {
    if (envSecrets[vaultKey] !== undefined) {
      vars[ansibleKey] = envSecrets[vaultKey];
    }
  }

  return vars;
}

async function writeAnsibleVaultFile(appName, envName, inventoryDir) {
  const vars = await generateAnsibleVars(appName, envName);

  const content = '---\n# Auto-generated by orchestrator from HashiCorp Vault — do not edit\n'
    + yaml.dump(vars, { lineWidth: 120, noRefs: true });

  const vaultFilePath = path.join(inventoryDir, 'group_vars', 'all', 'vault.yml');
  fs.mkdirSync(path.dirname(vaultFilePath), { recursive: true });
  fs.writeFileSync(vaultFilePath, content, { mode: 0o600 });

  logger.info('ansible-vars', `Generated vault vars at ${vaultFilePath}`);
  return vaultFilePath;
}

module.exports = { generateAnsibleVars, writeAnsibleVaultFile };
