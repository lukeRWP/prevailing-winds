const fs = require('fs');
const path = require('path');
const vault = require('./vault');
const appRegistry = require('./appRegistry');
const logger = require('../utils/logger');
const config = require('../config');

// Map manifest role names to Terraform tfvars keys
const ROLE_KEY_MAP = {
  database: 'db',
  storage: 'minio',
  client: 'client',
  server: 'server',
};

async function generateTfvars(appName, envName) {
  const app = appRegistry.get(appName);
  if (!app) throw new Error(`App not found: ${appName}`);

  const env = app.environments[envName];
  if (!env) throw new Error(`Environment not found: ${envName}`);

  const infraSecrets = await vault.readSecret('secret/data/pw/infra');
  if (!infraSecrets) throw new Error('Infra secrets not available from Vault');

  const vmIps = {};
  const vmExternalIps = {};

  for (const [role, hostConfig] of Object.entries(env.hosts || {})) {
    const roleKey = ROLE_KEY_MAP[role] || role;
    vmIps[roleKey] = hostConfig.ip;
    if (hostConfig.externalIp) {
      vmExternalIps[roleKey] = hostConfig.externalIp;
    }
  }

  const vars = {
    app_name: appName,
    environment: envName,
    target_node: Object.values(env.hosts || {})[0]?.proxmoxNode || 'prx002',
    env_vlan_tag: env.vlan,
    env_cidr: env.cidr,
    proxmox_api_url: infraSecrets.proxmox_api_url,
    ssh_public_key: infraSecrets.ssh_public_key,
    vm_ips: vmIps,
  };

  if (Object.keys(vmExternalIps).length > 0) {
    vars.vm_external_ips = vmExternalIps;
  }

  // Prod anti-affinity: DB on different node than other VMs
  if (envName === 'prod' && env.hosts?.database?.proxmoxNode) {
    const dbNode = env.hosts.database.proxmoxNode;
    if (dbNode !== vars.target_node) {
      vars.prod_db_node = dbNode;
    }
  }

  return vars;
}

function generateSharedTfvars(appName) {
  return {
    app_name: appName || 'imp',
    environment: 'shared',
    deploy_shared: false,
    manage_cluster_resources: true,
    env_vlan_tag: 87,
    env_cidr: '10.0.5.0/24',
  };
}

function formatTfvars(vars) {
  const lines = ['# Auto-generated by orchestrator â€” do not edit'];

  for (const [key, value] of Object.entries(vars)) {
    if (value === null || value === undefined) continue;

    if (typeof value === 'object') {
      const entries = Object.entries(value)
        .map(([k, v]) => `  ${k} = "${v}"`)
        .join('\n');
      lines.push(`\n${key} = {\n${entries}\n}`);
    } else if (typeof value === 'boolean') {
      lines.push(`${key} = ${value}`);
    } else if (typeof value === 'number') {
      lines.push(`${key} = ${value}`);
    } else {
      lines.push(`${key} = "${value}"`);
    }
  }

  return lines.join('\n') + '\n';
}

async function writeTfvars(appName, envName) {
  const isShared = envName === 'shared';
  const vars = isShared
    ? generateSharedTfvars(appName)
    : await generateTfvars(appName, envName);

  const content = formatTfvars(vars);
  const tfDir = path.join(config.orchestratorHome, 'terraform', 'environments');
  fs.mkdirSync(tfDir, { recursive: true });

  const filePath = path.join(tfDir, `${envName}.tfvars`);
  fs.writeFileSync(filePath, content, 'utf8');

  logger.info('tfvars', `Generated ${filePath}`);
  return filePath;
}

module.exports = { generateTfvars, generateSharedTfvars, formatTfvars, writeTfvars };
