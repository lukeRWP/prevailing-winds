const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');
const logger = require('../utils/logger');
const appRegistry = require('./appRegistry');

// Default hostname prefixes per role
const DEFAULT_ROLE_PREFIXES = {
  client: 'client',
  server: 'server',
  database: 'db',
  storage: 'minio'
};

/**
 * Generate Ansible inventory YAML for an environment from the app manifest.
 * Matches the existing inventory format in infra/ansible/inventories/<env>/hosts.yml
 */
function generateInventory(appName, envName) {
  const app = appRegistry.get(appName);
  if (!app) throw new Error(`App not found: ${appName}`);

  const env = (app.environments || {})[envName];
  if (!env) throw new Error(`Environment not found: ${appName}/${envName}`);

  const inventory = {
    all: {
      vars: {
        env_name: envName,
        ansible_user: 'deploy',
        ansible_ssh_common_args: '-o StrictHostKeyChecking=accept-new'
      },
      children: {}
    }
  };

  // Resolve group names from manifest's ansibleGroups field, or default to <app>_<role>s
  const ansibleGroups = app.ansibleGroups || {};

  // Build host groups from the environment's hosts definition
  for (const [role, hostConfig] of Object.entries(env.hosts || {})) {
    const groupName = ansibleGroups[role] || `${appName}_${role}s`;
    const prefix = DEFAULT_ROLE_PREFIXES[role] || role;
    const hostname = `${appName}-${prefix}-${envName}`;

    inventory.all.children[groupName] = {
      hosts: {
        [hostname]: {
          ansible_host: hostConfig.ip
        }
      }
    };
  }

  // Add empty monitoring group (parameterized per app)
  const monitoringGroup = ansibleGroups.monitoring || `${appName}_monitoring`;
  inventory.all.children[monitoringGroup] = { hosts: {} };

  return inventory;
}

/**
 * Write the generated inventory to the repo's inventories directory.
 * Creates the directory structure if it doesn't exist.
 */
function writeInventory(appName, envName, repoPath, { inventoryBaseDir } = {}) {
  const inventory = generateInventory(appName, envName);

  let inventoryDir;
  if (inventoryBaseDir) {
    // Direct path — used by lifecycle orchestrator (PW repo layout)
    inventoryDir = path.join(inventoryBaseDir, envName);
  } else {
    // Derived from app manifest infraPath — used by API endpoint
    const app = appRegistry.get(appName);
    const infraPath = app.infraPath || 'infra';
    inventoryDir = path.join(repoPath, infraPath, 'ansible', 'inventories', envName);
  }

  // Create directory structure
  fs.mkdirSync(inventoryDir, { recursive: true });

  // Also create group_vars/all directory for vault/vars files
  const groupVarsDir = path.join(inventoryDir, 'group_vars', 'all');
  fs.mkdirSync(groupVarsDir, { recursive: true });

  const hostsPath = path.join(inventoryDir, 'hosts.yml');
  const header = `# Auto-generated by orchestrator from ${appName}/app.yml\n# Environment: ${envName}\n# Do not edit manually — regenerate via POST /api/_y_/apps/${appName}/envs/${envName}/inventory\n`;
  const content = header + yaml.dump(inventory, { lineWidth: 120, noRefs: true });

  fs.writeFileSync(hostsPath, content, 'utf8');
  logger.info('inventory', `Generated inventory: ${hostsPath}`);

  return hostsPath;
}

/**
 * Return inventory YAML as a string without writing to disk.
 */
function renderInventory(appName, envName) {
  const inventory = generateInventory(appName, envName);
  const header = `# Auto-generated by orchestrator from ${appName}/app.yml\n# Environment: ${envName}\n`;
  return header + yaml.dump(inventory, { lineWidth: 120, noRefs: true });
}

module.exports = { generateInventory, writeInventory, renderInventory };
